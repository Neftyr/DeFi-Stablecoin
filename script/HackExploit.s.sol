// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Script, console} from "forge-std/Script.sol";

contract HackExploit is Script {
    error Challenge__HackFailed();
    error LessonTwelve__AHAHAHAHAHA();

    address private constant HUNTED = 0xe5760847db2f10A74Fc575B4803df5fe129811C1;
    address private constant TARGET = 0x5Cbd7Feb522f3060985Ddb07929eB7ee12568a48;
    address private constant WHO = 0x0522b7114f8603F0B94f887785C7ba77afca6205;
    address private constant OWNER = 0x643315C9Be056cDEA171F4e7b2222a4ddaB9F88D;
    address private constant HACKER = 0xcb11F38172fb2552938C2eEAf873339029DD52e3;

    function run() external {
        uint256 deployerKey = vm.envUint("PRIVATE_KEY");
        string memory hacker = "nseen18";

        vm.startBroadcast(deployerKey);
        //vm.startPrank(HUNTED);

        // (bool successOne, bytes memory numberrBytes) = TARGET.call(abi.encodeWithSignature("getNumberr()"));
        // (bool successTwo, bytes memory ownerBytes) = TARGET.call(abi.encodeWithSignature("getOwner()"));

        // uint128 numberr = abi.decode(numberrBytes, (uint128));
        // address exploitOwner = abi.decode(ownerBytes, (address));

        // console.log("Number: ", numberr);
        // console.log("Owner: ", exploitOwner);
        // printStorageData(TARGET, 6);
        // (bool success, bytes memory numberrBytes) = TARGET.call(abi.encodeWithSignature("hellFunc(uint128)", 18875456464566545666465333));

        // if (success) {
        //     uint128 numberr = abi.decode(numberrBytes, (uint128));
        //     console.log("Number Found!: ", numberr);
        // }
        //if (!success) revert Challenge__HackFailed();
        (bool success, ) = HUNTED.call(abi.encodeWithSignature("solveChallenge(address,string)", HACKER, hacker));
        if (!success) revert Challenge__HackFailed();
        vm.stopBroadcast();
        //vm.stopPrank();
    }

    function isUInt128(uint256 num) public pure returns (bool) {
        uint128 maxValue = 2 ** 128 - 1;
        return num <= maxValue;
    }

    function printStorageData(address contractAddress, uint256 i) public view {
        for (i = 0; i <= 6; i++) {
            bytes32 value = vm.load(contractAddress, bytes32(i));
            console.log("Value at location", i, ":");
            console.log("Address: ", address(uint160(uint256(value))));
            console.log("Number: ", uint256(value));
            console.logBytes32(value);
        }
    }

    function printFirstArrayElement(address contractAddress) public view {
        bytes32 arrayStorageSlotLength = bytes32(uint256(2));
        bytes32 firstElementStorageSlot = keccak256(abi.encode(arrayStorageSlotLength));
        bytes32 value = vm.load(contractAddress, firstElementStorageSlot);
        console.log("First element in array:");
        console.logBytes32(value);
    }

    function exploitFinder(string memory randomSelector) external {
        (bool success, ) = TARGET.call(abi.encodeWithSignature(randomSelector));
    }

    function solveChallenge(address exploitContract, string memory yourTwitterHandle) external {
        (bool successOne, bytes memory numberrBytes) = exploitContract.call(abi.encodeWithSignature("getNumberr()"));
        (bool successTwo, bytes memory ownerBytes) = exploitContract.call(abi.encodeWithSignature("getOwner()"));

        if (!successOne || !successTwo) {
            revert LessonTwelve__AHAHAHAHAHA();
        }

        uint128 numberr = abi.decode(numberrBytes, (uint128));
        address exploitOwner = abi.decode(ownerBytes, (address));

        if (msg.sender != exploitOwner) {
            revert LessonTwelve__AHAHAHAHAHA();
        }

        // try i_hellContract.hellFunc(numberr) returns (uint256) {
        //     revert LessonTwelve__AHAHAHAHAHA();
        // } catch {
        //     _updateAndRewardSolver(yourTwitterHandle);
        // }
    }
}
